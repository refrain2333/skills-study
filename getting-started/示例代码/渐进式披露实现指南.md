# ğŸ“ æ¸è¿›å¼æŠ«éœ²ï¼ˆProgressive Disclosureï¼‰å®ç°æŒ‡å—

## æ¦‚å¿µ

**æ¸è¿›å¼æŠ«éœ²**æ˜¯æŒ‡åœ¨ç³»ç»Ÿå¯åŠ¨æ—¶åªåŠ è½½**å¿…è¦çš„æœ€å°‘ä¿¡æ¯**ï¼Œç„¶åæ ¹æ®éœ€è¦**åŠ¨æ€åŠ è½½å®Œæ•´å†…å®¹**ã€‚

```
å¯åŠ¨æ—¶ï¼ˆè½»é‡çº§ï¼‰
  â”œâ”€ Skill 1: åç§° + ç®€çŸ­æè¿°
  â”œâ”€ Skill 2: åç§° + ç®€çŸ­æè¿°
  â””â”€ Skill N: åç§° + ç®€çŸ­æè¿°
  
  â†“ å½“éœ€è¦æŸä¸ª skill æ—¶
  
åŠ¨æ€åŠ è½½ï¼ˆæŒ‰éœ€ï¼‰
  â””â”€ Skill 1: å®Œæ•´å†…å®¹ï¼ˆè¯¦ç»†æŒ‡å—ã€ä»£ç ç¤ºä¾‹ã€å‚è€ƒèµ„æºï¼‰
```

---

## ğŸ’¾ å­˜å‚¨ç»“æ„è®¾è®¡

### ç¬¬ä¸€æ­¥ï¼šå°† Skills åˆ†å±‚

```python
# skills_registry.py

class SkillMetadata:
    """è½»é‡çº§ skill å…ƒæ•°æ®"""
    def __init__(self, name: str, description: str, category: str, 
                 file_path: str, tags: List[str]):
        self.name = name
        self.description = description  # ç®€çŸ­æè¿°ï¼ˆ1-2å¥è¯ï¼‰
        self.category = category        # åˆ†ç±»
        self.file_path = file_path      # å®Œæ•´å†…å®¹ä½ç½®
        self.tags = tags                # æ ‡ç­¾ï¼ˆç”¨äºæœç´¢ï¼‰
        self.loaded = False             # æ˜¯å¦å·²åŠ è½½

class SkillContent:
    """å®Œæ•´ skill å†…å®¹ï¼ˆæŒ‰éœ€åŠ è½½ï¼‰"""
    def __init__(self, metadata: SkillMetadata):
        self.metadata = metadata
        self.full_text = None           # å®Œæ•´æ–‡æœ¬
        self.sections = {}              # å„éƒ¨åˆ†å†…å®¹
        self.examples = []              # ä»£ç ç¤ºä¾‹
        self.references = []            # å‚è€ƒé“¾æ¥
```

### ç¬¬äºŒæ­¥ï¼šè®¾è®¡å¿«é€Ÿç´¢å¼•

```python
# å¿«é€ŸåŠ è½½çš„ skill ç´¢å¼•ï¼ˆæ€»å¤§å° < 10KBï¼‰

SKILLS_INDEX = {
    "context-fundamentals": {
        "name": "ä¸Šä¸‹æ–‡å·¥ç¨‹åŸºç¡€",
        "description": "ç†è§£ä¸Šä¸‹æ–‡çª—å£ã€æ³¨æ„åŠ›é¢„ç®—å’Œä¸Šä¸‹æ–‡è´¨é‡",
        "category": "foundational",
        "tags": ["context", "fundamentals", "attention"],
        "file": "skills/context-fundamentals/SKILL.md",
        "size_bytes": 12500,
        "estimated_tokens": 2500,
        "prerequisites": [],
        "related": ["context-degradation", "context-compression"]
    },
    
    "multi-agent-patterns": {
        "name": "å¤šä»£ç†æ¶æ„æ¨¡å¼",
        "description": "è®¾è®¡ç›‘ç£è€…ã€å¯¹ç­‰ã€åˆ†å±‚ç­‰å¤šä»£ç†ç³»ç»Ÿ",
        "category": "architectural",
        "tags": ["multi-agent", "coordination", "patterns"],
        "file": "skills/multi-agent-patterns/SKILL.md",
        "size_bytes": 18000,
        "estimated_tokens": 3600,
        "prerequisites": ["context-fundamentals"],
        "related": ["tool-design", "memory-systems"]
    },
    
    # ... å…¶ä»– skills
}
```

---

## ğŸ”§ å®ç°æ–¹å¼

### æ–¹å¼1ï¼šæ–‡ä»¶ç³»ç»Ÿç‰ˆæœ¬ï¼ˆæ¨èï¼‰

```python
import os
import json
from pathlib import Path
from typing import Dict, Optional

class ProgressiveSkillLoader:
    """æ¸è¿›å¼ skill åŠ è½½å™¨"""
    
    def __init__(self, skills_dir: str):
        self.skills_dir = Path(skills_dir)
        self.index_file = self.skills_dir / "index.json"
        self.loaded_skills: Dict[str, dict] = {}
        self.metadata_cache = None
    
    def load_metadata_only(self) -> Dict[str, dict]:
        """
        ç¬¬ä¸€æ­¥ï¼šä»…åŠ è½½å…ƒæ•°æ®ï¼ˆ~10KBï¼‰
        å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œï¼Œéå¸¸å¿«
        """
        if self.metadata_cache:
            return self.metadata_cache
        
        # åŠ è½½è½»é‡çº§ç´¢å¼•
        with open(self.index_file, 'r', encoding='utf-8') as f:
            self.metadata_cache = json.load(f)
        
        print(f"âœ… åŠ è½½äº† {len(self.metadata_cache)} ä¸ª skill çš„å…ƒæ•°æ®")
        return self.metadata_cache
    
    def get_available_skills(self) -> Dict[str, str]:
        """è·å–æ‰€æœ‰å¯ç”¨ skills çš„åç§°å’Œæè¿°"""
        metadata = self.load_metadata_only()
        return {
            skill_id: f"{skill['name']} - {skill['description']}"
            for skill_id, skill in metadata.items()
        }
    
    def load_full_skill(self, skill_id: str) -> Optional[str]:
        """
        ç¬¬äºŒæ­¥ï¼šæŒ‰éœ€åŠ è½½å®Œæ•´ skill å†…å®¹
        ä»…åœ¨éœ€è¦æ—¶åŠ è½½å®Œæ•´æ–‡ä»¶
        """
        if skill_id in self.loaded_skills:
            return self.loaded_skills[skill_id]
        
        metadata = self.load_metadata_only()
        if skill_id not in metadata:
            return None
        
        # åŠ è½½å®Œæ•´æ–‡ä»¶
        skill_file = self.skills_dir / metadata[skill_id]['file']
        with open(skill_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        self.loaded_skills[skill_id] = content
        print(f"âœ… åŠ è½½äº†å®Œæ•´ skill: {metadata[skill_id]['name']}")
        
        return content
    
    def get_skills_by_category(self, category: str) -> Dict[str, str]:
        """æŒ‰ç±»åˆ«è·å– skills"""
        metadata = self.load_metadata_only()
        return {
            skill_id: skill['name']
            for skill_id, skill in metadata.items()
            if skill['category'] == category
        }
    
    def search_skills(self, query: str) -> Dict[str, dict]:
        """æœç´¢ skillsï¼ˆåŸºäºå…ƒæ•°æ®ï¼‰"""
        metadata = self.load_metadata_only()
        query_lower = query.lower()
        
        results = {}
        for skill_id, skill in metadata.items():
            # åœ¨åç§°ã€æè¿°ã€æ ‡ç­¾ä¸­æœç´¢
            if (query_lower in skill['name'].lower() or
                query_lower in skill['description'].lower() or
                any(query_lower in tag.lower() for tag in skill.get('tags', []))):
                results[skill_id] = {
                    'name': skill['name'],
                    'description': skill['description'],
                    'tokens': skill.get('estimated_tokens', 0)
                }
        
        return results
```

### index.json ç¤ºä¾‹

```json
{
  "context-fundamentals": {
    "name": "ä¸Šä¸‹æ–‡å·¥ç¨‹åŸºç¡€",
    "description": "ç†è§£ä¸Šä¸‹æ–‡çª—å£ã€æ³¨æ„åŠ›é¢„ç®—å’Œä¸Šä¸‹æ–‡è´¨é‡",
    "category": "foundational",
    "tags": ["context", "fundamentals", "attention", "budget"],
    "file": "context-fundamentals/SKILL.md",
    "size_bytes": 12500,
    "estimated_tokens": 2500,
    "prerequisites": [],
    "related": ["context-degradation", "context-compression"]
  },
  
  "multi-agent-patterns": {
    "name": "å¤šä»£ç†æ¶æ„æ¨¡å¼",
    "description": "è®¾è®¡ç›‘ç£è€…ã€å¯¹ç­‰ã€åˆ†å±‚ç­‰å¤šä»£ç†ç³»ç»Ÿ",
    "category": "architectural",
    "tags": ["multi-agent", "coordination", "patterns"],
    "file": "multi-agent-patterns/SKILL.md",
    "size_bytes": 18000,
    "estimated_tokens": 3600,
    "prerequisites": ["context-fundamentals"],
    "related": ["tool-design", "memory-systems"]
  },
  
  "context-degradation": {
    "name": "ä¸Šä¸‹æ–‡å¤±è´¥æ¨¡å¼",
    "description": "è¯†åˆ«ä¸¢å¤±ä¸­é—´ã€ä¸­æ¯’ã€å¹²æ‰°ç­‰ä¸Šä¸‹æ–‡å¤±è´¥",
    "category": "foundational",
    "tags": ["context", "degradation", "failure"],
    "file": "context-degradation/SKILL.md",
    "size_bytes": 10000,
    "estimated_tokens": 2000,
    "prerequisites": ["context-fundamentals"],
    "related": ["context-compression", "context-optimization"]
  }
}
```

---

## ğŸš€ ä½¿ç”¨ç¤ºä¾‹

### åœºæ™¯1ï¼šAgent å¯åŠ¨æ—¶åˆ—å‡ºå¯ç”¨ skills

```python
# åˆå§‹åŒ–ï¼ˆ<1ç§’ï¼‰
loader = ProgressiveSkillLoader("./skills")

# æ˜¾ç¤ºæ‰€æœ‰å¯ç”¨ skillsï¼ˆæå¿«ï¼Œåªç”¨å…ƒæ•°æ®ï¼‰
available = loader.get_available_skills()
print("å¯ç”¨çš„ skills:")
for skill_id, description in available.items():
    print(f"  - {skill_id}: {description}")

# è¾“å‡ºï¼š
# å¯ç”¨çš„ skills:
#   - context-fundamentals: ä¸Šä¸‹æ–‡å·¥ç¨‹åŸºç¡€ - ç†è§£ä¸Šä¸‹æ–‡çª—å£ã€...
#   - multi-agent-patterns: å¤šä»£ç†æ¶æ„æ¨¡å¼ - è®¾è®¡ç›‘ç£è€…ã€å¯¹ç­‰ã€...
#   - context-degradation: ä¸Šä¸‹æ–‡å¤±è´¥æ¨¡å¼ - è¯†åˆ«ä¸¢å¤±ä¸­é—´ã€...
```

### åœºæ™¯2ï¼šAgent æœç´¢ç›¸å…³ skills

```python
# ç”¨æˆ·è¾“å…¥ï¼š"æˆ‘æƒ³äº†è§£å¤šä»£ç†ç³»ç»Ÿ"
query = "å¤šä»£ç†"

# æœç´¢ï¼ˆåªæœç´¢å…ƒæ•°æ®ï¼‰
results = loader.search_skills(query)
print(f"æœç´¢ç»“æœï¼ˆç”¨æ—¶ <10msï¼‰:")
for skill_id, info in results.items():
    print(f"  {info['name']}")
    print(f"    å¤§å°: ~{info['tokens']} tokens")
    print()

# è¾“å‡ºï¼š
# æœç´¢ç»“æœï¼ˆç”¨æ—¶ <10msï¼‰:
#   å¤šä»£ç†æ¶æ„æ¨¡å¼
#     å¤§å°: ~3600 tokens
```

### åœºæ™¯3ï¼šAgent éœ€è¦æŸä¸ª skill æ—¶åŠ¨æ€åŠ è½½

```python
# Agent å†³å®šéœ€è¦äº†è§£å¤šä»£ç†ç³»ç»Ÿ
skill_id = "multi-agent-patterns"

# åŠ è½½å®Œæ•´å†…å®¹ï¼ˆæŒ‰éœ€ï¼‰
content = loader.load_full_skill(skill_id)

# ç°åœ¨å¯ä»¥åœ¨ LLM æç¤ºä¸­ä½¿ç”¨è¿™ä¸ªå†…å®¹
llm_prompt = f"""
{system_prompt}

ç›¸å…³æ–‡æ¡£ï¼š
{content}

ç”¨æˆ·é—®é¢˜ï¼š{user_question}
"""

response = llm.call(llm_prompt)
```

---

## ğŸ¯ åœ¨ä»£ç†ç³»ç»Ÿä¸­çš„åº”ç”¨

### å®Œæ•´ç¤ºä¾‹ï¼šæ™ºèƒ½ä»£ç†ç³»ç»Ÿ

```python
from dataclasses import dataclass
from enum import Enum

class AgentState(Enum):
    INITIALIZING = "initializing"
    READY = "ready"
    REASONING = "reasoning"
    EXECUTING = "executing"

@dataclass
class Agent:
    """æ™ºèƒ½ä»£ç†ï¼Œæ”¯æŒæ¸è¿›å¼ skill åŠ è½½"""
    name: str
    skill_loader: ProgressiveSkillLoader
    context_budget: int = 8000  # tokens
    
    def __init__(self, name: str, skills_dir: str):
        self.name = name
        self.skill_loader = ProgressiveSkillLoader(skills_dir)
        self.used_tokens = 0
        self.active_skills = []
        self.state = AgentState.INITIALIZING
    
    def initialize(self) -> dict:
        """
        åˆå§‹åŒ–ï¼šåŠ è½½å…ƒæ•°æ®
        æ—¶é—´ï¼š< 1ç§’
        """
        print("ğŸš€ ä»£ç†åˆå§‹åŒ–ä¸­...")
        
        # åŠ è½½æ‰€æœ‰ skill å…ƒæ•°æ®ï¼ˆè½»é‡çº§ï¼‰
        available = self.skill_loader.get_available_skills()
        
        self.state = AgentState.READY
        
        return {
            "available_skills": len(available),
            "ready": True,
            "skills": list(available.keys())
        }
    
    def plan_task(self, task: str) -> dict:
        """
        è§„åˆ’ï¼šåŸºäºä»»åŠ¡ç¡®å®šéœ€è¦å“ªäº› skills
        åªä½¿ç”¨å…ƒæ•°æ®ï¼Œæå¿«
        """
        print(f"ğŸ“‹ è§„åˆ’ä»»åŠ¡: {task}")
        
        # åˆ†æä»»åŠ¡ï¼Œæœç´¢ç›¸å…³ skills
        relevant_skills = self.skill_loader.search_skills(task)
        
        # ä¼°ç®—éœ€è¦çš„ tokens
        estimated_tokens = sum(
            skill['tokens'] for skill in relevant_skills.values()
        )
        
        if estimated_tokens > self.context_budget:
            print(f"âš ï¸  éœ€è¦ {estimated_tokens} tokensï¼Œé¢„ç®—ä¸º {self.context_budget}")
            # é€‰æ‹©æœ€ç›¸å…³çš„ skills
            sorted_skills = sorted(
                relevant_skills.items(),
                key=lambda x: x[1]['tokens'],
                reverse=True
            )
            selected = dict(sorted_skills[:len(self.context_budget) // 1000])
            relevant_skills = selected
        
        self.active_skills = list(relevant_skills.keys())
        
        return {
            "relevant_skills": relevant_skills,
            "estimated_tokens": estimated_tokens,
            "selected_skills": self.active_skills
        }
    
    def execute_task(self, task: str, user_question: str) -> str:
        """
        æ‰§è¡Œï¼šæŒ‰éœ€åŠ è½½é€‰ä¸­ skillsï¼Œæ‰§è¡Œä»»åŠ¡
        """
        print(f"âš™ï¸  æ‰§è¡Œä»»åŠ¡...")
        self.state = AgentState.EXECUTING
        
        # ç¬¬1æ­¥ï¼šè§„åˆ’
        plan = self.plan_task(task)
        
        # ç¬¬2æ­¥ï¼šåŠ è½½ skillsï¼ˆæŒ‰éœ€ï¼‰
        loaded_content = {}
        for skill_id in self.active_skills:
            print(f"  ğŸ“¥ åŠ è½½ skill: {skill_id}")
            content = self.skill_loader.load_full_skill(skill_id)
            if content:
                loaded_content[skill_id] = content
        
        # ç¬¬3æ­¥ï¼šæ„å»ºæç¤º
        skills_context = "\n\n".join([
            f"## {skill_id}\n{content[:500]}..."  # æ‘˜è¦
            for skill_id, content in loaded_content.items()
        ])
        
        prompt = f"""
{self.get_system_prompt()}

## å¯ç”¨æŠ€èƒ½æ–‡æ¡£

{skills_context}

## ç”¨æˆ·é—®é¢˜
{user_question}

è¯·åŸºäºä¸Šè¿°æŠ€èƒ½æ–‡æ¡£å›ç­”ç”¨æˆ·é—®é¢˜ã€‚
"""
        
        # ç¬¬4æ­¥ï¼šè°ƒç”¨ LLM
        response = self.call_llm(prompt)
        
        self.state = AgentState.READY
        return response
    
    def get_system_prompt(self) -> str:
        return """ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ä»£ç†ã€‚æ ¹æ®æä¾›çš„æŠ€èƒ½æ–‡æ¡£æ¥å›ç­”é—®é¢˜ã€‚"""
    
    def call_llm(self, prompt: str) -> str:
        # è¿™é‡Œåº”è¯¥è°ƒç”¨å®é™…çš„ LLM API
        return "LLM å“åº”"
```

---

## ğŸ’¡ ä¼˜åŒ–æŠ€å·§

### 1. å¤šå±‚ç¼“å­˜

```python
class CachedSkillLoader(ProgressiveSkillLoader):
    """æ”¯æŒå¤šå±‚ç¼“å­˜çš„ skill åŠ è½½å™¨"""
    
    def __init__(self, skills_dir: str):
        super().__init__(skills_dir)
        self.memory_cache = {}      # å†…å­˜ç¼“å­˜
        self.compression_enabled = True
    
    def load_full_skill(self, skill_id: str) -> Optional[str]:
        # ç¬¬1å±‚ï¼šå†…å­˜ç¼“å­˜
        if skill_id in self.memory_cache:
            return self.memory_cache[skill_id]
        
        # ç¬¬2å±‚ï¼šæ–‡ä»¶ç³»ç»Ÿ
        content = super().load_full_skill(skill_id)
        
        if content:
            # ç¼“å­˜åˆ°å†…å­˜
            self.memory_cache[skill_id] = content
        
        return content
    
    def get_skill_summary(self, skill_id: str, max_length: int = 500) -> str:
        """è·å– skill çš„æ‘˜è¦ï¼ˆä¸åŠ è½½å®Œæ•´å†…å®¹ï¼‰"""
        content = self.load_full_skill(skill_id)
        # æå–å‰ max_length ä¸ªå­—ç¬¦ä½œä¸ºæ‘˜è¦
        return content[:max_length] + "..."
```

### 2. å¹¶è¡ŒåŠ è½½

```python
import concurrent.futures

class ParallelSkillLoader(ProgressiveSkillLoader):
    """æ”¯æŒå¹¶è¡ŒåŠ è½½çš„ skill åŠ è½½å™¨"""
    
    def load_multiple_skills(self, skill_ids: List[str], max_workers: int = 4) -> Dict[str, str]:
        """å¹¶è¡ŒåŠ è½½å¤šä¸ª skills"""
        result = {}
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {
                executor.submit(self.load_full_skill, skill_id): skill_id
                for skill_id in skill_ids
            }
            
            for future in concurrent.futures.as_completed(futures):
                skill_id = futures[future]
                try:
                    content = future.result()
                    if content:
                        result[skill_id] = content
                except Exception as e:
                    print(f"âŒ åŠ è½½ {skill_id} å¤±è´¥: {e}")
        
        return result
```

### 3. æ™ºèƒ½é¢„åŠ è½½

```python
class PredictiveSkillLoader(ProgressiveSkillLoader):
    """é¢„æµ‹æ€§åŠ è½½ - åŸºäºå†å²é¢„åŠ è½½å¯èƒ½éœ€è¦çš„ skills"""
    
    def __init__(self, skills_dir: str):
        super().__init__(skills_dir)
        self.usage_history = {}  # è®°å½•å“ªäº› skills ç»å¸¸ä¸€èµ·ä½¿ç”¨
    
    def predict_related_skills(self, current_skill: str) -> List[str]:
        """åŸºäºå½“å‰ skill é¢„æµ‹å¯èƒ½éœ€è¦çš„ç›¸å…³ skills"""
        metadata = self.load_metadata_only()
        current = metadata.get(current_skill, {})
        
        # è¿”å›ç›¸å…³ skills
        return current.get('related', [])
    
    def preload_likely_skills(self, current_skill: str):
        """é¢„åŠ è½½å¯èƒ½éœ€è¦çš„ç›¸å…³ skills"""
        related = self.predict_related_skills(current_skill)
        
        print(f"ğŸ”„ é¢„åŠ è½½ç›¸å…³ skills: {related}")
        for skill_id in related:
            if skill_id not in self.loaded_skills:
                self.load_full_skill(skill_id)
```

---

## ğŸ“Š æ€§èƒ½å¯¹æ¯”

### ä¸ä½¿ç”¨æ¸è¿›å¼æŠ«éœ²

```
å¯åŠ¨æ—¶é—´ï¼š2-3 ç§’ï¼ˆåŠ è½½æ‰€æœ‰ 50 ä¸ª skillsï¼‰
å†…å­˜å ç”¨ï¼š50-100 MB
é¦–æ¬¡å“åº”ï¼š2-3 ç§’
```

### ä½¿ç”¨æ¸è¿›å¼æŠ«éœ²

```
å¯åŠ¨æ—¶é—´ï¼š< 100msï¼ˆåªåŠ è½½å…ƒæ•°æ®ï¼‰
å†…å­˜å ç”¨ï¼š< 1 MB
é¦–æ¬¡å“åº”ï¼š< 500msï¼ˆåŠ è½½éœ€è¦çš„ skillsï¼‰
```

**æ€§èƒ½æå‡ï¼š10-20 å€** ğŸš€

---

## ğŸ¯ å®ç°æ£€æŸ¥æ¸…å•

- [ ] åˆ›å»º `index.json` åŒ…å«æ‰€æœ‰ skills çš„å…ƒæ•°æ®
- [ ] å®ç° `ProgressiveSkillLoader` ç±»
- [ ] æ·»åŠ å…ƒæ•°æ®åŠ è½½æ–¹æ³•ï¼ˆå¿«é€Ÿï¼‰
- [ ] æ·»åŠ æŒ‰éœ€åŠ è½½æ–¹æ³•ï¼ˆå»¶è¿Ÿï¼‰
- [ ] å®ç°æœç´¢åŠŸèƒ½ï¼ˆåŸºäºå…ƒæ•°æ®ï¼‰
- [ ] å®ç°ç¼“å­˜æœºåˆ¶
- [ ] æ·»åŠ é”™è¯¯å¤„ç†
- [ ] é›†æˆåˆ°ä»£ç†ç³»ç»Ÿ
- [ ] æµ‹è¯•æ€§èƒ½

---

## ğŸ”— ç›¸å…³æ¦‚å¿µ

è¿™ä¸ªå®ç°åº”ç”¨äº†ä»¥ä¸‹ Agent Skills ä¸­çš„åŸç†ï¼š

1. **context-fundamentals** - ç†è§£ä¸ºä»€ä¹ˆè¦èŠ‚çœä¸Šä¸‹æ–‡
2. **tool-design** - å·¥å…·å’Œ skills çš„æ¸…æ™°è®¾è®¡
3. **project-development** - ç®¡é“æ¨¡å¼ï¼ˆåŠ è½½ã€å¤„ç†ï¼‰

---

å¸Œæœ›è¿™ä¸ªè¯¦ç»†çš„å®ç°æŒ‡å—å¯¹ä½ æœ‰å¸®åŠ©ï¼æœ‰ä»€ä¹ˆå…·ä½“çš„é—®é¢˜å¯ä»¥ç»§ç»­é—®ã€‚

