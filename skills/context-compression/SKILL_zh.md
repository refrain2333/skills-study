---
name: 上下文压缩
description: 为长期运行的代理会话设计和评估上下文压缩策略。当代理耗尽内存、需要总结对话历史，或在优化每个任务的令牌数（而非每个请求的令牌数）时使用。
---

# 上下文压缩策略

当代理会话产生数百万个令牌的对话历史时，压缩变得必不可少。朴素的方法是激进压缩以最小化每个请求的令牌数。正确的优化目标是**每个任务的令牌数 (tokens-per-task)**：即完成任务所消耗的总令牌数，包括压缩丢失关键信息时导致的重新获取成本。

## 何时激活

在以下情况下激活本技能：
- 代理会话超过上下文窗口限制
- 代码库超过上下文窗口（500万+ 令牌系统）
- 设计对话摘要策略
- 调试代理“忘记”修改了哪些文件的情况
- 构建压缩质量的评估框架

## 核心概念

上下文压缩在令牌节省与信息丢失之间进行权衡。存在三种生产级方法：

1. **锚定迭代摘要 (Anchored Iterative Summarization)**：维护结构化的持久摘要，包含会话意图、文件修改、决策和后续步骤的显式部分。当触发压缩时，仅总结新截断的部分并与现有摘要合并。结构化通过为特定信息类型设立专门章节来强制保留信息。

2. **不透明压缩 (Opaque Compression)**：生成针对重建忠实度优化的压缩表示。达到最高的压缩率（99%+），但牺牲了可读性。无法验证保留了哪些内容。

3. **再生全量摘要 (Regenerative Full Summary)**：在每次压缩时生成详细的结构化摘要。生成可读的输出，但由于是全量再生而非增量合并，在重复的压缩周期中可能会丢失细节。

**关键洞察**：结构强制保留。专用章节充当摘要器必须填充的检查清单，防止信息无声漂移。

## 详细主题

### 为什么“每个任务的令牌数”很重要

传统的压缩指标针对每个请求的令牌数（tokens-per-request）。这是一个错误的优化方向。当压缩丢失了文件路径或错误消息等关键细节时，代理必须重新获取信息、重新探索方法，并浪费令牌来恢复上下文。

正确的指标是**每个任务的令牌数 (tokens-per-task)**：从任务开始到完成所消耗的总令牌数。一个虽然能多节省 0.5% 令牌但导致 20% 额外重新获取成本的压缩策略，总体成本更高。

### 产物追踪问题

产物追踪（Artifact trail）的完整性是所有压缩方法中最薄弱的维度，在评估中得分仅为 2.2-2.5（满分 5.0）。即使是带有显式文件章节的结构化摘要，在长期会话中也难以维持完整的文件跟踪。

编码代理需要知道：
- 创建了哪些文件
- 修改了哪些文件以及更改了什么
- 读取了但未更改哪些文件
- 函数名、变量名、错误消息

这个问题可能需要通用摘要之外的专门处理：单独的产物索引或在代理支架（scaffolding）中进行显式文件状态跟踪。

### 结构化摘要章节

有效的结构化摘要包括显式章节：

```markdown
## 会话意图
[用户试图实现的目标]

## 已修改文件
- auth.controller.ts: 修复了 JWT 令牌生成
- config/redis.ts: 更新了连接池
- tests/auth.test.ts: 为新配置添加了模拟设置

## 已做决策
- 使用 Redis 连接池而非每个请求建立连接
- 针对瞬时故障使用指数退避的重试逻辑

## 当前状态
- 14 个测试通过，2 个失败
- 剩余工作：为会话服务测试进行模拟设置

## 后续步骤
1. 修复剩余的测试失败
2. 运行完整测试套件
3. 更新文档
```

这种结构可以防止无声地丢失文件路径或决策，因为每个章节都必须被显式处理。

### 压缩触发策略

何时触发压缩与如何压缩同样重要：

| 策略 | 触发点 | 权衡 |
|----------|---------------|-----------|
| 固定阈值 | 70-80% 上下文利用率 | 简单但可能压缩过早 |
| 滑动窗口 | 保留最后 N 轮 + 摘要 | 可预测的上下文大小 |
| 基于重要性 | 首先压缩相关性较低的部分 | 复杂但保留了信号 |
| 任务边界 | 在逻辑任务完成时压缩 | 摘要清晰但时间不可预测 |

对于大多数编码代理用例，结合结构化摘要的滑动窗口方法在可预测性和质量之间提供了最佳平衡。

### 基于探针的评估

ROUGE 或嵌入相似度等传统指标无法捕捉功能性压缩质量。摘要可能在词汇重叠上得分很高，但遗漏了代理所需的一个文件路径。

基于探针的评估通过在压缩后提问来直接衡量功能质量：

| 探针类型 | 测试内容 | 示例问题 |
|------------|---------------|------------------|
| 召回 (Recall) | 事实保留 | "最初的错误消息是什么？" |
| 产物 (Artifact) | 文件跟踪 | "我们修改了哪些文件？" |
| 连续 (Continuation) | 任务规划 | "我们下一步该做什么？" |
| 决策 (Decision) | 推理链 | "关于 Redis 问题我们决定了什么？" |

如果压缩保留了正确的信息，代理能正确回答。否则，它会猜测或产生幻觉。

### 评估维度

六个维度捕捉编码代理的压缩质量：

1. **准确性 (Accuracy)**：技术细节是否正确？文件路径、函数名、错误代码。
2. **上下文感知 (Context Awareness)**：响应是否反映了当前的对话状态？
3. **产物追踪 (Artifact Trail)**：代理是否知道哪些文件被读取或修改？
4. **完整性 (Completeness)**：响应是否回答了问题的各部分？
5. **连续性 (Continuity)**：是否可以继续工作而无需重新获取信息？
6. **指令遵循 (Instruction Following)**：响应是否尊重规定的约束？

准确性在不同压缩方法之间表现出最大的差异（0.6 分差距）。产物追踪普遍较弱（2.2-2.5 范围）。

## 实践指南

### 三阶段压缩工作流

对于超过上下文窗口的大型代码库或代理系统，通过三个阶段应用压缩：

1. **研究阶段**：根据架构图、文档和关键接口生成研究文档。将探索过程压缩为对组件和依赖关系的结构化分析。输出：单份研究文档。

2. **规划阶段**：将研究转化为带有函数签名、类型定义和数据流的实现规范。一个 500 万令牌的代码库可压缩为约 2000 字的规范。

3. **实现阶段**：针对规范执行。上下文保持集中在规范上，而非原始代码库的探索。

### 使用示例产物作为种子

当提供手动迁移示例或参考 PR 时，将其作为模板来理解目标模式。示例揭示了静态分析无法发现的约束：必须保持哪些不变量、哪些服务在更改时会中断，以及干净的迁移是什么样的。

当代理无法区分本质复杂性（业务需求）与偶然复杂性（旧代码的变通方案）时，这一点尤为重要。示例产物编码了这种区别。

### 实现锚定迭代摘要

1. 定义符合代理需求的显式摘要章节
2. 在第一次触发压缩时，将截断的历史记录总结到各个章节中
3. 在后续压缩时，仅总结新的截断内容
4. 将新摘要合并到现有章节中，而非重新生成
5. 跟踪哪些信息来自哪个压缩周期以便调试

### 何时使用每种方法

**在以下情况下使用锚定迭代摘要：**
- 会话运行时间长（100+ 消息）
- 文件跟踪至关重要（编码、调试）
- 需要验证保留了哪些内容

**在以下情况下使用不透明压缩：**
- 需要最大的令牌节省
- 会话相对较短
- 重新获取成本较低

**在以下情况下使用再生摘要：**
- 摘要的可读性至关重要
- 会话有明确的阶段边界
- 每次压缩时进行全量上下文审查是可以接受的

### 压缩率考量

| 方法 | 压缩率 | 质量得分 | 权衡 |
|--------|-------------------|---------------|-----------|
| 锚定迭代 | 98.6% | 3.70 | 质量最好，压缩率略低 |
| 再生 | 98.7% | 3.44 | 质量良好，压缩率中等 |
| 不透明 | 99.3% | 3.35 | 压缩率最高，质量损失较大 |

结构化摘要多保留的 0.7% 令牌换取了 0.35 分的质量提升。对于任何重新获取成本很重要的任务，这种权衡都倾向于结构化方法。

## 示例

**示例 1：调试会话压缩**

原始上下文（89,000 令牌，178 条消息）：
- /api/auth/login 接口出现 401 错误
- 追踪了 auth 控制器、中间件、会话存储
- 发现 Redis 连接陈旧
- 修复了连接池，添加了重试逻辑
- 14 个测试通过，2 个失败

压缩后的结构化摘要：

```markdown
## 会话意图
调试 /api/auth/login 上的 401 Unauthorized 错误（尽管凭据有效）。

## 根本原因
会话存储中的 Redis 连接陈旧。JWT 生成正确，但会话无法持久化。

## 已修改文件
- auth.controller.ts: 无更改（仅读取）
- middleware/cors.ts: 无更改（已检查）
- config/redis.ts: 修复了连接池配置
- services/session.service.ts: 为瞬时故障添加了重试逻辑
- tests/auth.test.ts: 更新了模拟设置

## 测试状态
14 个通过，2 个失败（模拟设置问题）

## 后续步骤
1. 修复剩余的测试失败（模拟会话服务）
2. 运行完整测试套件
3. 部署到预发环境
```

**示例 2：探针响应质量**

压缩后提问：“最初的错误是什么？”

**良好的响应（结构化摘要）：**
> “最初的错误是来自 /api/auth/login 接口的 401 Unauthorized 响应。用户在使用有效凭据时收到此错误。根本原因是会话存储中的 Redis 连接陈旧。”

**糟糕的响应（激进压缩）：**
> “我们正在调试一个身份验证问题。登录失败了。我们修复了一些配置问题。”

结构化响应保留了端点、错误代码和根本原因。激进响应丢失了所有技术细节。

## 指南

1. 优化每个任务的令牌数，而非每个请求的令牌数
2. 使用结构化摘要，并设立显式的文件跟踪章节
3. 在上下文利用率达到 70-80% 时触发压缩
4. 实现增量合并而非全量再生
5. 使用基于探针的评估测试压缩质量
6. 如果文件跟踪至关重要，请单独跟踪产物路径
7. 接受稍低的压缩率以换取更好的质量保留
8. 监控重新获取频率，将其作为压缩质量的信号

## 集成

此技能与本系列中的其他技能相关联：

- context-degradation - 压缩是缓解退化的策略
- context-optimization - 压缩是众多优化技术之一
- evaluation - 基于探针的评估适用于压缩测试
- memory-systems - 压缩与暂存器和摘要内存模式相关

## 参考文献

内部参考：
- [评估框架参考](./references/evaluation-framework_zh.md) - 详细的探针类型和评分标准

本系列中的相关技能：
- context-degradation - 理解压缩要防止什么
- context-optimization - 更广泛的优化策略
- evaluation - 构建评估框架

外部资源：
- Factory Research: Evaluating Context Compression for AI Agents (December 2025)
- Research on LLM-as-judge evaluation methodology (Zheng et al., 2023)
- Netflix Engineering: "The Infinite Software Crisis" - Three-phase workflow and context compression at scale (AI Summit 2025)

---

## 技能元数据

**创建日期**: 2025-12-22
**最后更新**: 2025-12-26
**作者**: Agent Skills for Context Engineering Contributors
**版本**: 1.1.0

