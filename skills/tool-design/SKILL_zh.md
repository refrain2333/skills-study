---
name: tool-design
description: 设计智能体可以有效使用的工具，包括何时减少工具复杂性。在创建、优化或精简智能体工具集时使用。
---

# 智能体工具设计

工具是智能体与世界互动的核心机制。它们定义了确定性系统与非确定性智能体之间的契约。与专为开发人员设计的传统软件 API 不同，工具 API 必须为推理意图、推断参数值并从自然语言请求生成调用的语言模型而设计。糟糕的工具设计会产生任何提示词工程都无法修复的故障模式。有效的工具设计遵循特定的原则，这些原则考虑了智能体如何感知和使用工具。

## 何时激活

在以下情况下激活此技能：
- 为智能体系统创建新工具
- 调试与工具相关的故障或误用
- 优化现有工具集以获得更好的智能体性能
- 从头设计工具 API
- 评估第三方工具以进行智能体集成
- 在代码库中标准化工具约定

## 核心概念

工具是确定性系统与非确定性智能体之间的契约。**合并原则（Consolidation Principle）**指出，如果人类工程师无法明确说明在特定情况下应该使用哪个工具，那么就不能指望智能体做得更好。有效的工具描述本身就是塑造智能体行为的提示词工程。

关键原则包括：清晰的描述（回答“是什么”、“何时用”和“返回什么”）；平衡完整性和 Token 效率的响应格式；能够实现恢复的错误消息；以及降低认知负荷的一致约定。

## 详细主题

### 工具-智能体接口

**工具即契约**
工具是确定性系统与非确定性智能体之间的契约。当人类调用 API 时，他们理解契约并发出适当的请求。智能体必须从描述中推断契约，并生成符合预期格式的调用。

这种根本差异需要重新思考 API 设计。契约必须明确无误，示例必须说明预期模式，错误消息必须引导更正。工具定义中的每一个歧义都会成为潜在的故障模式。

**工具描述即提示词**
工具描述被加载到智能体上下文中，并共同引导其行为。描述不仅是文档——它们是塑造智能体如何思考工具使用的提示词工程。

诸如“搜索数据库”之类的糟糕描述加上晦涩的参数名称会迫使智能体去猜测。优化的描述包括使用上下文、示例和默认值。描述回答了：工具做什么，何时使用，以及它产生什么。

**命名空间和组织**
随着工具集的增长，组织变得至关重要。命名空间将相关的工具分在共同的前缀下，帮助智能体在正确的时间选择合适的工具。

命名空间创造了功能的清晰边界。当智能体需要数据库信息时，它会路由到数据库命名空间。当它需要网页搜索时，它会路由到网页命名空间。

### 合并原则

**单一综合工具**
合并原则指出，如果人类工程师无法明确说明在特定情况下应该使用哪个工具，那么就不能指望智能体做得更好。这导致人们倾向于使用单一的综合工具，而不是多个狭窄的工具。

与其实现 `list_users`、`list_events` 和 `create_event`，不如实现一个 `schedule_event` 来查找可用性并进行调度。综合工具在内部处理整个工作流，而不是要求智能体链接多个调用。

**为什么合并有效**
智能体的上下文和注意力是有限的。工具集中的每个工具都在工具选择阶段争夺注意力。每个工具都会增加消耗上下文预算的描述 Token。重叠的功能会产生关于该使用哪个工具的歧义。

合并通过消除冗余描述来减少 Token 消耗。它通过让一个工具涵盖每个工作流来消除歧义。它通过缩小有效工具集来降低工具选择的复杂性。

**何时不合并**
合并并非普遍正确。具有根本不同行为的工具应保持分离。在不同上下文中使用的工具受益于分离。可能被独立调用的工具不应被人为地捆绑在一起。

### 架构精简（Architectural Reduction）

合并原则如果推向逻辑极致，就会导致架构精简：移除大多数专用工具，转而采用原始的、通用的能力。生产实践证明，这种方法可以优于复杂的多工具架构。

**文件系统智能体模式**
与其为数据探索、模式查找和查询验证构建自定义工具，不如通过单个命令执行工具提供直接的文件系统访问。智能体使用标准的 Unix 实用程序（grep、cat、find、ls）来探索、理解和操作你的系统。

这之所以奏效是因为：
1. 文件系统是一种经过验证的抽象，模型对其有深刻的理解
2. 标准工具具有可预测且文档齐全的行为
3. 智能体可以灵活地链接原始能力，而不是受限于预定义的工作流
4. 文件中的良好文档取代了摘要工具的需求

**精简优于复杂的情况**
精简在以下情况下奏效：
- 你的数据层文档齐全且结构一致
- 模型具有足够的推理能力来导航复杂性
- 你的专用工具是在限制模型而不是赋能模型
- 你花在维护脚手架上的时间超过了改进产出的时间

精简在以下情况下失败：
- 你的底层数据杂乱、不一致或文档匮乏
- 领域需要模型缺乏的专业知识
- 安全约束需要限制智能体的操作
- 操作确实非常复杂，受益于结构化的工作流

**停止约束推理**
一种常见的反模式是构建工具来“保护”模型免受复杂性的影响。预过滤上下文、限制选项、将交互包装在验证逻辑中。随着模型的改进，这些护栏通常会变成负担。

要问的问题是：你的工具是在赋能新的能力，还是在约束模型本可以自行处理的推理？

**为未来的模型构建**
模型的进步速度超过了工具的更新速度。为今天的模型优化的架构可能会对明天的模型产生过度约束。构建可以从模型改进中受益的极简架构，而不是锁定当前局限性的复杂架构。

参见 [架构精简案例研究](./references/architectural_reduction_zh.md) 以获取生产证据。

### 工具描述工程

**描述结构**
有效的工具描述回答四个问题：

该工具做什么？清晰、具体的功能描述。避免使用“有助于”或“可用于”之类的模糊语言。准确说明工具完成了什么。

何时应该使用？具体的触发因素和上下文。包括直接触发因素（“用户询问定价”）和间接信号（“需要当前市场价格”）。

它接受什么输入？带有类型、约束和默认值的参数描述。解释每个参数控制什么。

它返回什么？输出格式和结构。包括成功响应和错误条件的示例。

**默认参数选择**
默认值应反映常见用例。它们通过消除不必要的参数指定来减轻智能体的负担。它们可以防止因省略参数而导致的错误。

### 响应格式优化

工具响应的大小显著影响上下文使用。实现响应格式选项可以让智能体控制详细程度。

**简明格式**仅返回基本字段，适用于确认或基本信息。**详细格式**返回带有所有字段的完整对象，适用于决策需要完整上下文的情况。

在工具描述中包含关于何时使用每种格式的指导。智能体会学习根据任务要求选择合适的格式。

### 错误消息设计

错误消息服务于两类受众：调试问题的开发人员和从故障中恢复的智能体。对于智能体来说，错误消息必须是**可操作的**。它们必须告诉智能体出了什么问题以及如何纠正。

设计能够实现恢复的错误消息。对于可重试的错误，包含重试指导。对于输入错误，包含纠正后的格式。对于缺失数据，包含所需内容。

### 工具定义模式（Schema）

在所有工具中使用一致的模式。建立命名规范：工具名称采用动词-名词模式，跨工具一致的参数名称，一致的返回字段名称。

### 工具集设计

研究表明，工具描述重叠会导致模型混淆。更多的工具并不总是带来更好的结果。大多数应用程序的合理准则是 10-20 个工具。如果需要更多，请使用命名空间创建逻辑分组。

实施帮助智能体选择正确工具的机制：工具分组、基于示例的选择，以及带有路由到专用子工具的伞状工具的层次结构。

### MCP 工具命名要求

在使用 MCP（模型上下文协议）工具时，始终使用全限定工具名称，以避免“找不到工具”错误。

格式：`ServerName:tool_name`

```python
# 正确：全限定名称
"使用 BigQuery:bigquery_schema 工具来检索表模式。"
"使用 GitHub:create_issue 工具来创建 Issue。"

# 错误：未限定名称
"使用 bigquery_schema 工具..."  # 在有多个服务器时可能会失败
```

如果没有服务器前缀，智能体可能无法定位工具，尤其是在有多个 MCP 服务器可用时。建立在所有工具引用中包含服务器上下文的命名规范。

### 使用智能体优化工具

Claude 可以优化它自己的工具。当给定一个工具并观察到故障模式时，它可以诊断问题并建议改进。生产测试显示，这种方法通过帮助未来的智能体避免错误，使任务完成时间缩短了 40%。

**工具测试智能体模式**：

```python
def optimize_tool_description(tool_spec, failure_examples):
    """
    使用智能体分析工具故障并改进描述。
    
    过程：
    1. 智能体尝试在不同任务中使用工具
    2. 收集故障模式和摩擦点
    3. 智能体分析故障并提出改进建议
    4. 针对相同任务测试改进后的描述
    """
    prompt = f"""
    分析此工具规范和观察到的故障。
    
    工具: {tool_spec}
    
    观察到的故障:
    {failure_examples}
    
    识别:
    1. 为什么智能体在使用此工具时失败
    2. 描述中缺失了哪些信息
    3. 哪些歧义导致了错误用法
    
    提出一个解决这些问题的改进后的工具描述。
    """
    
    return get_agent_response(prompt)
```

这创造了一个反馈循环：使用工具的智能体生成故障数据，然后智能体利用这些数据改进工具描述，从而减少未来的故障。

### 测试工具设计

根据以下标准评估工具设计：无歧义性、完整性、可恢复性、效率和一致性。通过展示代表性的智能体请求并评估生成的工具调用来测试工具。

## 实践指南

### 要避免的反模式

**模糊描述**：“搜索数据库以获取客户信息”留下了太多未回答的问题。

**晦涩的参数名称**：名为 x、val 或 param1 的参数会迫使智能体猜测含义。

**缺失错误处理**：因通用错误而失败的工具无法提供恢复指导。

**命名不一致**：在某些工具中使用 `id`，在其他工具中使用 `identifier`，而在某些工具中使用 `customer_id` 会造成混淆。

### 工具选择框架

在设计工具集时：
1. 确定智能体必须完成的独特工作流
2. 将相关操作分组到综合工具中
3. 确保每个工具都有清晰、明确的目的
4. 记录错误情况和恢复路径
5. 使用实际的智能体交互进行测试

## 示例

**示例 1：设计良好的工具**
```python
def get_customer(customer_id: str, format: str = "concise"):
    """
    通过 ID 检索客户信息。
    
    使用场景:
    - 用户询问特定客户详情
    - 决策需要客户上下文
    - 验证客户身份
    
    参数:
        customer_id: 格式为 "CUST-######" (例如 "CUST-000001")
        format: "concise" 返回关键字段，"detailed" 返回完整记录
    
    返回:
        带有请求字段的客户对象
    
    错误:
        NOT_FOUND: 找不到客户 ID
        INVALID_FORMAT: ID 必须符合 CUST-###### 模式
    """
```

**示例 2：糟糕的工具设计**

此示例展示了几个工具设计反模式：

```python
def search(query):
    """搜索数据库。"""
    pass
```

**此设计的问题：**

1. **名称模糊**：“search” 是模糊的——搜索什么，出于什么目的？
2. **缺失参数**：什么数据库？查询应该采用什么格式？
3. **没有返回描述**：此函数返回什么？列表？字符串？错误处理？
4. **没有使用上下文**：智能体何时应该使用此工具而不是其他工具？
5. **没有错误处理**：如果数据库不可用会发生什么？

**故障模式：**
- 智能体可能会在应该使用更具体的工具时调用此工具
- 智能体无法确定正确的查询格式
- 智能体无法解释结果
- 智能体无法从故障中恢复

## 指南

1. 编写回答“是什么”、“何时用”和“返回什么”的描述
2. 使用合并来减少歧义
3. 实现响应格式选项以提高 Token 效率
4. 为智能体恢复设计错误消息
5. 建立并遵循一致的命名规范
6. 限制工具数量并使用命名空间进行组织
7. 使用实际的智能体交互测试工具设计
8. 根据观察到的故障模式进行迭代
9. 质疑每个工具是赋能还是约束模型
10. 倾向于使用原始、通用的工具，而不是专用的包装器
11. 在文档质量上投入，而不是工具的复杂性
12. 构建可从模型改进中受益的极简架构

## 集成

此技能连接到：
- context-fundamentals - 工具如何与上下文互动
- multi-agent-patterns - 每个智能体的专用工具
- evaluation - 评估工具的有效性

## 参考资料

内部参考：
- [最佳实践参考](./references/best_practices_zh.md) - 详细的工具设计指南
- [架构精简案例研究](./references/architectural_reduction_zh.md) - 工具极简主义的生产证据

此系列中的相关技能：
- context-fundamentals - 工具上下文交互
- evaluation - 工具测试模式

外部资源：
- MCP (Model Context Protocol) 文档
- 框架工具规范
- 针对智能体的 API 设计最佳实践
- Vercel d0 智能体架构案例研究

---

## 技能元数据

**创建日期**: 2025-12-20
**上次更新**: 2025-12-23
**作者**: Agent Skills for Context Engineering Contributors
**版本**: 1.1.0

